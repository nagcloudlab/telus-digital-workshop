name: Deploy to AWS Staging

on:
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  ENVIRONMENT: staging

jobs:
  # Job 0: Complete Cleanup
  cleanup:
    name: üßπ Cleanup Existing Infrastructure
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üßπ Complete Cleanup of All Resources
      run: |
        echo "========================================"
        echo "Complete Cleanup of Money Transfer Resources"
        echo "========================================"
        
        # 1. Terminate EC2 Instances
        echo "1. Terminating EC2 instances..."
        INSTANCE_IDS=$(aws ec2 describe-instances --region ${{ env.AWS_REGION }} \
          --filters "Name=tag:Name,Values=money-transfer-app" \
                    "Name=instance-state-name,Values=running,stopped,pending,stopping" \
          --query 'Reservations[].Instances[].InstanceId' --output text 2>/dev/null || echo "")
        
        if [ ! -z "$INSTANCE_IDS" ]; then
          for instance_id in $INSTANCE_IDS; do
            echo "   Terminating: $instance_id"
            aws ec2 terminate-instances --instance-ids $instance_id --region ${{ env.AWS_REGION }} || true
          done
          echo "   Waiting 60 seconds for termination..."
          sleep 60
        else
          echo "   ‚è≠Ô∏è  No instances to terminate"
        fi
        
        # 2. Release Elastic IPs
        echo "2. Releasing Elastic IPs..."
        
        # Tagged EIPs
        EIP_ALLOCS=$(aws ec2 describe-addresses --region ${{ env.AWS_REGION }} \
          --filters "Name=tag:Name,Values=money-transfer-eip" \
          --query 'Addresses[].AllocationId' --output text 2>/dev/null || echo "")
        
        for eip in $EIP_ALLOCS; do
          if [ ! -z "$eip" ]; then
            echo "   Releasing tagged EIP: $eip"
            # Disassociate first if associated
            ASSOC_ID=$(aws ec2 describe-addresses --allocation-ids $eip --query 'Addresses[0].AssociationId' --output text 2>/dev/null || echo "")
            if [ "$ASSOC_ID" != "None" ] && [ ! -z "$ASSOC_ID" ]; then
              aws ec2 disassociate-address --association-id $ASSOC_ID --region ${{ env.AWS_REGION }} 2>/dev/null || true
              sleep 5
            fi
            aws ec2 release-address --allocation-id $eip --region ${{ env.AWS_REGION }} 2>/dev/null || true
          fi
        done
        
        # All unattached EIPs
        UNATTACHED=$(aws ec2 describe-addresses --region ${{ env.AWS_REGION }} \
          --query 'Addresses[?AssociationId==null].AllocationId' --output text 2>/dev/null || echo "")
        
        for eip in $UNATTACHED; do
          if [ ! -z "$eip" ]; then
            echo "   Releasing unattached EIP: $eip"
            aws ec2 release-address --allocation-id $eip --region ${{ env.AWS_REGION }} 2>/dev/null || true
          fi
        done
        
        echo "   ‚úÖ EIPs released"
        
        # 3. Delete Security Groups
        echo "3. Deleting security groups..."
        
        # Wait a bit more for instances to fully terminate
        sleep 15
        
        # Find all security groups with our name pattern
        SG_IDS=$(aws ec2 describe-security-groups --region ${{ env.AWS_REGION }} \
          --filters "Name=group-name,Values=money-transfer-ec2-sg*" \
          --query 'SecurityGroups[].GroupId' --output text 2>/dev/null || echo "")
        
        for sg_id in $SG_IDS; do
          if [ ! -z "$sg_id" ]; then
            echo "   Deleting security group: $sg_id"
            # Try multiple times as it may still be in use
            for i in {1..10}; do
              aws ec2 delete-security-group --group-id $sg_id --region ${{ env.AWS_REGION }} 2>/dev/null && echo "   ‚úÖ Deleted $sg_id" && break || sleep 10
            done
          fi
        done
        
        # 4. Delete Key Pairs
        echo "4. Deleting SSH key pairs..."
        KEY_NAMES=$(aws ec2 describe-key-pairs --region ${{ env.AWS_REGION }} \
          --filters "Name=key-name,Values=money-transfer-key*" \
          --query 'KeyPairs[].KeyName' --output text 2>/dev/null || echo "")
        
        for key_name in $KEY_NAMES; do
          if [ ! -z "$key_name" ]; then
            echo "   Deleting key: $key_name"
            aws ec2 delete-key-pair --key-name $key_name --region ${{ env.AWS_REGION }} || true
          fi
        done
        
        echo "   ‚úÖ Key pairs deleted"
        
        # 5. Delete IAM Resources
        echo "5. Deleting IAM resources..."
        
        # Find all roles with our name pattern
        ROLE_NAMES=$(aws iam list-roles --query 'Roles[?starts_with(RoleName, `money-transfer-ec2-role`)].RoleName' --output text 2>/dev/null || echo "")
        
        for role_name in $ROLE_NAMES; do
          if [ ! -z "$role_name" ]; then
            echo "   Processing role: $role_name"
            
            # Detach policies
            POLICIES=$(aws iam list-attached-role-policies --role-name $role_name \
              --query 'AttachedPolicies[].PolicyArn' --output text 2>/dev/null || echo "")
            for policy in $POLICIES; do
              echo "     Detaching policy: $policy"
              aws iam detach-role-policy --role-name $role_name --policy-arn $policy 2>/dev/null || true
            done
            
            # Remove from instance profiles
            PROFILES=$(aws iam list-instance-profiles-for-role --role-name $role_name \
              --query 'InstanceProfiles[].InstanceProfileName' --output text 2>/dev/null || echo "")
            for profile in $PROFILES; do
              echo "     Removing from profile: $profile"
              aws iam remove-role-from-instance-profile --instance-profile-name $profile --role-name $role_name 2>/dev/null || true
              aws iam delete-instance-profile --instance-profile-name $profile 2>/dev/null || true
            done
            
            # Delete role
            aws iam delete-role --role-name $role_name 2>/dev/null && echo "     ‚úÖ Deleted role" || echo "     ‚ö†Ô∏è  Could not delete role"
          fi
        done
        
        # Also clean orphaned instance profiles
        PROFILE_NAMES=$(aws iam list-instance-profiles --query 'InstanceProfiles[?starts_with(InstanceProfileName, `money-transfer-ec2-profile`)].InstanceProfileName' --output text 2>/dev/null || echo "")
        
        for profile_name in $PROFILE_NAMES; do
          if [ ! -z "$profile_name" ]; then
            echo "   Deleting orphaned profile: $profile_name"
            aws iam delete-instance-profile --instance-profile-name $profile_name 2>/dev/null || true
          fi
        done
        
        echo "   ‚úÖ IAM resources cleaned"
        
        echo ""
        echo "========================================"
        echo "‚úÖ Cleanup Complete!"
        echo "========================================"

  # Job 1: Build JAR
  build:
    name: üî® Build Application
    runs-on: ubuntu-latest
    needs: cleanup
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: ‚òï Setup Java 17
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'
        cache: maven
    
    - name: üî® Build with Maven
      run: |
        cd money-transfer
        mvn clean package -DskipTests
        echo "‚úÖ Build complete"
    
    - name: üì¶ Upload JAR artifact
      uses: actions/upload-artifact@v4
      with:
        name: money-transfer-jar
        path: money-transfer/target/*.jar
        retention-days: 1

  # Job 2: Deploy Infrastructure with Terraform
  terraform-deploy:
    name: üèóÔ∏è Terraform Infrastructure
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: staging
    
    outputs:
      ec2_public_ip: ${{ steps.terraform-outputs.outputs.ec2_public_ip }}
      ec2_instance_id: ${{ steps.terraform-outputs.outputs.ec2_instance_id }}
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
    
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üèóÔ∏è Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0
        terraform_wrapper: false
    
    - name: üîß Terraform Init
      working-directory: money-transfer/infrastructure/terraform/aws/staging
      run: |
        echo "Initializing Terraform..."
        rm -rf .terraform/
        rm -f terraform.tfstate*
        rm -f tfplan
        terraform init
        echo "‚úÖ Terraform initialized"
    
    - name: üìã Terraform Plan
      working-directory: money-transfer/infrastructure/terraform/aws/staging
      env:
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
      run: |
        echo "Planning infrastructure changes..."
        terraform plan -out=tfplan -input=false
        echo "‚úÖ Terraform plan created"
    
    - name: üöÄ Terraform Apply
      working-directory: money-transfer/infrastructure/terraform/aws/staging
      env:
        TF_VAR_ssh_public_key: ${{ secrets.SSH_PUBLIC_KEY }}
      run: |
        echo "Applying infrastructure changes..."
        terraform apply -auto-approve -input=false tfplan
        echo "‚úÖ Infrastructure deployed"
    
    - name: üìä Get Terraform Outputs
      id: terraform-outputs
      working-directory: money-transfer/infrastructure/terraform/aws/staging
      run: |
        echo "Retrieving Terraform outputs..."
        
        EC2_IP=$(terraform output -raw ec2_public_ip)
        EC2_ID=$(terraform output -raw ec2_instance_id)
        APP_URL=$(terraform output -raw application_url)
        
        echo "ec2_public_ip=$EC2_IP" >> $GITHUB_OUTPUT
        echo "ec2_instance_id=$EC2_ID" >> $GITHUB_OUTPUT
        
        echo "=================================="
        echo "Infrastructure Outputs"
        echo "=================================="
        echo "EC2 Public IP: $EC2_IP"
        echo "EC2 Instance ID: $EC2_ID"
        echo "Application URL: $APP_URL"
        echo "=================================="

  # Job 3: Deploy Application to EC2
  deploy-app:
    name: üöÄ Deploy Application
    runs-on: ubuntu-latest
    needs: terraform-deploy
    environment:
      name: staging
      url: http://${{ needs.terraform-deploy.outputs.ec2_public_ip }}:8080
    
    steps:
    - name: üîê Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: üì• Download JAR artifact
      uses: actions/download-artifact@v4
      with:
        name: money-transfer-jar
        path: ./artifacts
    
    - name: üîç Verify JAR Downloaded
      run: |
        echo "Checking for JAR file..."
        ls -lah ./artifacts/
        JAR_COUNT=$(ls -1 ./artifacts/*.jar 2>/dev/null | wc -l)
        if [ $JAR_COUNT -eq 0 ]; then
          echo "‚ùå ERROR: No JAR file found!"
          exit 1
        fi
        echo "‚úÖ Found $JAR_COUNT JAR file(s)"
    
    - name: üîë Setup SSH Key
      run: |
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > money-transfer-key.pem
        chmod 600 money-transfer-key.pem
        ls -lah money-transfer-key.pem
    
    - name: ‚è≥ Wait for EC2 to be ready
      env:
        EC2_IP: ${{ needs.terraform-deploy.outputs.ec2_public_ip }}
      run: |
        echo "Waiting for EC2 instance to be ready..."
        echo "EC2 IP: ${EC2_IP}"
        
        for i in {1..40}; do
          if ssh -i money-transfer-key.pem -o StrictHostKeyChecking=no -o ConnectTimeout=5 ubuntu@${EC2_IP} "echo 'ready'" 2>/dev/null; then
            echo "‚úÖ EC2 is ready!"
            exit 0
          fi
          echo "Attempt $i/40: Waiting for SSH..."
          sleep 15
        done
        echo "‚ùå EC2 not ready after 10 minutes"
        exit 1
    
    - name: üì§ Upload JAR to EC2
      env:
        EC2_IP: ${{ needs.terraform-deploy.outputs.ec2_public_ip }}
      run: |
        echo "Finding JAR file..."
        JAR_FILE=$(ls -1 ./artifacts/*.jar | head -1)
        
        if [ -z "$JAR_FILE" ]; then
          echo "‚ùå ERROR: No JAR file found in artifacts directory!"
          ls -lah ./artifacts/
          exit 1
        fi
        
        echo "Found JAR: $JAR_FILE"
        ls -lah "$JAR_FILE"
        
        echo "Uploading JAR to EC2..."
        scp -v -i money-transfer-key.pem -o StrictHostKeyChecking=no \
          "$JAR_FILE" ubuntu@${EC2_IP}:/tmp/money-transfer.jar
        
        echo "Verifying upload..."
        ssh -i money-transfer-key.pem -o StrictHostKeyChecking=no ubuntu@${EC2_IP} \
          "ls -lah /tmp/money-transfer.jar"
        
        echo "‚úÖ JAR uploaded successfully"
    
    - name: üöÄ Deploy and Start Application
      env:
        EC2_IP: ${{ needs.terraform-deploy.outputs.ec2_public_ip }}
      run: |
        echo "Deploying application on EC2..."
        
        ssh -i money-transfer-key.pem -o StrictHostKeyChecking=no ubuntu@${EC2_IP} << 'ENDSSH'
          set -e
          
          echo "Checking if JAR exists..."
          if [ ! -f /tmp/money-transfer.jar ]; then
            echo "‚ùå ERROR: JAR file not found at /tmp/money-transfer.jar"
            ls -lah /tmp/
            exit 1
          fi
          
          echo "JAR file found, proceeding with deployment..."
          
          # Create application user if it doesn't exist
          echo "Creating application user..."
          sudo useradd -r -s /bin/false money-transfer 2>/dev/null || echo "User already exists"
          
          echo "Stopping existing service if running..."
          sudo systemctl stop money-transfer 2>/dev/null || echo "Service not running (first deployment)"
          
          echo "Creating application directory..."
          sudo mkdir -p /opt/money-transfer
          
          echo "Moving JAR to application directory..."
          sudo mv /tmp/money-transfer.jar /opt/money-transfer/money-transfer.jar
          
          echo "Setting permissions..."
          sudo chown money-transfer:money-transfer /opt/money-transfer/money-transfer.jar
          sudo chmod 755 /opt/money-transfer/money-transfer.jar
          sudo chown -R money-transfer:money-transfer /opt/money-transfer
          
          echo "Verifying JAR in final location..."
          ls -lah /opt/money-transfer/money-transfer.jar
          
          # Create systemd service if it doesn't exist
          if [ ! -f /etc/systemd/system/money-transfer.service ]; then
            echo "Creating systemd service..."
            sudo bash -c 'cat > /etc/systemd/system/money-transfer.service << SERVICE
[Unit]
Description=Money Transfer Application
After=network.target

[Service]
Type=simple
User=money-transfer
WorkingDirectory=/opt/money-transfer
ExecStart=/usr/bin/java -Xmx512m -Xms256m -jar /opt/money-transfer/money-transfer.jar
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal
SyslogIdentifier=money-transfer

[Install]
WantedBy=multi-user.target
SERVICE'
            echo "‚úÖ Systemd service created"
          else
            echo "Systemd service already exists"
          fi
          
          echo "Reloading systemd..."
          sudo systemctl daemon-reload
          
          echo "Enabling service..."
          sudo systemctl enable money-transfer
          
          echo "Starting service..."
          sudo systemctl start money-transfer
          
          echo "Waiting for startup..."
          sleep 20
          
          echo "Checking service status..."
          sudo systemctl status money-transfer --no-pager || true
          
          echo "Checking application logs..."
          sudo journalctl -u money-transfer -n 50 --no-pager
          
          echo "‚úÖ Application deployed and started"
        ENDSSH
        
        echo "‚úÖ Deployment complete"

  # Job 4: Health Check
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    needs: [terraform-deploy, deploy-app]
    
    steps:
    - name: ‚è≥ Wait for Application Warmup
      run: sleep 30
    
    - name: üè• Perform Health Check
      env:
        EC2_IP: ${{ needs.terraform-deploy.outputs.ec2_public_ip }}
      run: |
        echo "Checking application health..."
        echo "URL: http://${EC2_IP}:8080/actuator/health"
        echo ""
        
        MAX_ATTEMPTS=30
        ATTEMPT=0
        
        while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://${EC2_IP}:8080/actuator/health || echo "000")
          
          if [ "$HTTP_CODE" == "200" ]; then
            echo "‚úÖ Health check passed!"
            echo ""
            echo "Health response:"
            curl -s http://${EC2_IP}:8080/actuator/health | jq '.' 2>/dev/null || curl -s http://${EC2_IP}:8080/actuator/health
            exit 0
          fi
          
          ATTEMPT=$((ATTEMPT + 1))
          echo "Attempt $ATTEMPT/$MAX_ATTEMPTS - Status: $HTTP_CODE"
          sleep 10
        done
        
        echo "‚ùå Health check failed after $MAX_ATTEMPTS attempts"
        exit 1

  # Job 5: Deployment Summary
  deployment-summary:
    name: üìä Deployment Summary
    runs-on: ubuntu-latest
    needs: [terraform-deploy, deploy-app, health-check]
    if: always()
    
    steps:
    - name: üìä Generate Deployment Report
      env:
        EC2_IP: ${{ needs.terraform-deploy.outputs.ec2_public_ip }}
        EC2_ID: ${{ needs.terraform-deploy.outputs.ec2_instance_id }}
      run: |
        cat << EOF
        
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë                                           ‚ïë
        ‚ïë   ‚úÖ EC2 DEPLOYMENT SUCCESSFUL! ‚úÖ        ‚ïë
        ‚ïë                                           ‚ïë
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        
        ## üéâ Deployment Complete!
        
        ### üìç Access Points
        
        - **Application URL:** http://${EC2_IP}:8080
        - **Health Check:** http://${EC2_IP}:8080/actuator/health
        - **H2 Console:** http://${EC2_IP}:8080/h2-console
          - JDBC URL: jdbc:h2:mem:moneytransfer
          - Username: sa
          - Password: (leave empty)
        
        ### üñ•Ô∏è EC2 Instance Details
        
        - **Instance ID:** ${EC2_ID}
        - **Public IP:** ${EC2_IP}
        - **Region:** ${{ env.AWS_REGION }}
        - **Instance Type:** t3.small
        - **OS:** Ubuntu 22.04
        - **Java Version:** OpenJDK 17
        
        ### üîë SSH Access
        
        ssh -i money-transfer-key.pem ubuntu@${EC2_IP}
        
        ### üìä Application Management
        
        # View logs
        ssh ubuntu@${EC2_IP} 'sudo journalctl -u money-transfer -f'
        
        # Check status
        ssh ubuntu@${EC2_IP} 'sudo systemctl status money-transfer'
        
        # Restart application
        ssh ubuntu@${EC2_IP} 'sudo systemctl restart money-transfer'
        
        ### üß™ Test the Application
        
        # Health check
        curl http://${EC2_IP}:8080/actuator/health
        
        # H2 Console
        Open: http://${EC2_IP}:8080/h2-console
        
        ---
        
        **Deployment ID:** ${{ github.run_id }}
        **Deployed by:** ${{ github.actor }}
        **Commit:** ${{ github.sha }}
        **Region:** ${{ env.AWS_REGION }}
        
        EOF